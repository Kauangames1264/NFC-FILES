<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Proximity Sensor Demo v1.1</title> <!-- versão 1.1 -->
  <style>
    /* Estilo simples. Sem canvas. */
    :root{ --bg:#0b0b0f; --fg:#e6eef3; --accent:#3ddc84; --warn:#ff7b7b; }
    html,body{ height:100%; margin:0; font-family:Inter, Roboto, Arial; background:var(--bg); color:var(--fg); }
    .wrap{ max-width:760px; margin:28px auto; padding:20px; border-radius:10px; background:#071018; box-shadow:0 8px 30px rgba(0,0,0,.6); }
    h1{ margin:0 0 12px 0; font-size:20px; }
    p{ margin:6px 0 12px 0; color:#bcd3da; }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button{ background:var(--accent); border:0; color:#002; padding:8px 12px; border-radius:8px; cursor:pointer; }
    button.ghost{ background:transparent; border:1px solid #234; color:var(--fg); }
    .status{ padding:10px; border-radius:8px; background:#04151d; width:100%; box-sizing:border-box; }
    .big{ font-size:28px; font-weight:700; }
    .muted{ color:#7fa3ad; font-size:13px; }
    .warn{ color:var(--warn); font-weight:700; }
    video{ width:100%; max-height:360px; border-radius:8px; background:#000; }
    .field{ margin-top:10px; }
    small{ color:#8fb6be; }
    .log{ margin-top:12px; font-family: monospace; background:#021015; padding:10px; border-radius:8px; max-height:160px; overflow:auto; font-size:13px; color:#9fd7c9; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Demo Sensor de Proximidade — v1.1</h1>
    <p>Este site lê o sensor de proximidade (quando disponível) e dispara ações. Há fallback para eventos antigos e para navegadores sem suporte. Requer HTTPS em muitos navegadores.</p>

    <div class="row">
      <button id="startSensor">Iniciar sensor</button>
      <button id="stopSensor" class="ghost" disabled>Parar sensor</button>
      <button id="toggleCam" class="ghost">Mostrar câmera</button>
    </div>

    <div class="field status" id="statusBox">
      <div class="muted">Estado:</div>
      <div id="status" class="big">Inativo</div>
      <div class="muted">Última leitura: <span id="last">—</span></div>
    </div>

    <div class="field">
      <label class="muted">Valor atual (cm ou proximidade):</label>
      <div id="value" class="big">—</div>
      <div class="muted" id="nearFar">—</div>
    </div>

    <div class="field">
      <label class="muted">Ação quando próximo:</label>
      <div class="row">
        <button id="actionBeep">Tocar som curto</button>
        <button id="actionFlash" class="ghost">Alterar cor do status</button>
        <button id="actionCustom" class="ghost">Sem ação</button>
      </div>
    </div>

    <div class="field">
      <label class="muted">Câmera (opcional):</label>
      <video id="video" autoplay playsinline muted style="display:none"></video>
    </div>

    <div class="log" id="log">Log iniciado.</div>
  </div>

  <script>
    // Versão: 1.1
    // Objetivo: usar ProximitySensor quando disponível. Fallback para deviceproximity events. Mostrar cam opcional.
    // Observações de possíveis bugs: muitos navegadores não suportam ProximitySensor. Requer HTTPS e permissões.
    (function(){
      const startBtn = document.getElementById('startSensor');
      const stopBtn = document.getElementById('stopSensor');
      const statusEl = document.getElementById('status');
      const valueEl = document.getElementById('value');
      const lastEl = document.getElementById('last');
      const nearFarEl = document.getElementById('nearFar');
      const logEl = document.getElementById('log');
      const video = document.getElementById('video');
      const toggleCam = document.getElementById('toggleCam');

      let sensor = null;               // ProximitySensor instance (Generic Sensor API)
      let usingLegacy = false;         // fallback deviceproximity
      let stream = null;               // camera stream
      let lastReading = null;
      let nearThreshold = 5;           // cm aproximado, ajuste se necessário
      let currentAction = 'beep';      // ação padrão

      // util: log
      function log(msg){
        const time = new Date().toLocaleTimeString();
        logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
      }

      // ações ao detectar proximidade
      function onNear() {
        log('Evento NEAR detectado.');
        if (currentAction === 'beep') playBeep();
        if (currentAction === 'flash') flashStatus();
      }

      function onFar() {
        log('Evento FAR detectado.');
        // restaurar cor se necessário
        statusEl.style.color = '';
      }

      // som curto com WebAudio (compatível)
      function playBeep(){
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = 'sine';
          o.frequency.value = 880;
          o.connect(g); g.connect(ctx.destination);
          g.gain.value = 0.05;
          o.start();
          setTimeout(()=>{ o.stop(); ctx.close(); }, 120);
        } catch (e){ log('Erro ao tocar beep: ' + e.message); }
      }

      // muda cor do texto do status temporariamente
      function flashStatus(){
        statusEl.style.color = '#ffdd57';
        setTimeout(()=> statusEl.style.color = '', 400);
      }

      // iniciar câmera (opcional)
      async function startCamera(){
        if (stream) return;
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
          video.srcObject = stream;
          video.style.display = 'block';
          toggleCam.textContent = 'Ocultar câmera';
          log('Câmera iniciada.');
        } catch (e) {
          log('Falha ao acessar câmera: ' + e.message);
        }
      }

      function stopCamera(){
        if (!stream) return;
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
        video.srcObject = null;
        video.style.display = 'none';
        toggleCam.textContent = 'Mostrar câmera';
        log('Câmera parada.');
      }

      toggleCam.addEventListener('click', ()=>{
        if (stream) stopCamera(); else startCamera();
      });

      // iniciar leitura de sensor
      startBtn.addEventListener('click', async ()=>{
        startBtn.disabled = true;
        stopBtn.disabled = false;
        statusEl.textContent = 'Iniciando...';
        log('Tentando iniciar sensor de proximidade.');

        // Primeiro tente API moderna: Generic Sensor API (ProximitySensor)
        try {
          if ('ProximitySensor' in window) {
            sensor = new ProximitySensor({ frequency: 10 }); // frequência pode ser ajustada
            sensor.addEventListener('reading', ()=>{
              handleReading({distance: sensor.distance, max: sensor.max});
            });
            sensor.addEventListener('error', (ev)=>{
              log('Erro do sensor: ' + (ev.error ? ev.error.name : 'desconhecido'));
            });
            await sensor.start();
            statusEl.textContent = 'Ativo (ProximitySensor)';
            log('Usando ProximitySensor (API moderna).');
            return;
          }
        } catch (e) {
          log('ProximitySensor falhou: ' + e.message);
          // continua para fallback
        }

        // Fallback para eventos legados deviceproximity / userproximity
        try {
          if ('ondeviceproximity' in window || 'onuserproximity' in window) {
            usingLegacy = true;
            window.addEventListener('deviceproximity', legacyDeviceHandler);
            window.addEventListener('userproximity', legacyUserHandler);
            statusEl.textContent = 'Ativo (evento legado)';
            log('Usando eventos deviceproximity/userproxim
      if (!("NDEFReader" in window)) {
        alert("Web NFC não suportado neste dispositivo.");
      }
      // Verifica suporte a WebRTC
      if (!window.RTCPeerConnection) {
        alert("WebRTC não suportado neste navegador. A simulação de Wi‑Fi Direct não funcionará.");
      }
    }

    // Variáveis globais para definir o papel e armazenar a conexão
    let role;
    let peerConnection;
    let dataChannel;
    // Configuração básica do WebRTC (usando um servidor STUN público)
    const configuration = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    // Função para selecionar o papel
    function selectRole(selectedRole) {
      role = selectedRole;
      document.getElementById("roleSelection").classList.add("hidden");
      if (role === "host") {
        document.getElementById("hostUI").classList.remove("hidden");
      } else {
        document.getElementById("guestUI").classList.remove("hidden");
      }
    }

    // -------------------------
    // Fluxo para o HOST
    async function startHost() {
      setHostStatus("Criando conexão WebRTC...");
      // Cria a conexão e uma DataChannel para transferência de dados
      peerConnection = new RTCPeerConnection(configuration);
      dataChannel = peerConnection.createDataChannel("fileTransfer");

      // Quando a DataChannel abrir, habilitamos a área de transferência
      dataChannel.onopen = () => {
        setHostStatus("Conexão estabelecida! Você pode enviar arquivos.");
        document.getElementById("hostTransfer").classList.remove("hidden");
      };
      dataChannel.onerror = (error) => {
        setHostStatus("Erro na DataChannel: " + error);
      };

      // Coleta de ICE candidates
      peerConnection.onicecandidate = async (event) => {
        if (event.candidate === null) { // Final dos candidatos
          let offer = peerConnection.localDescription;
          setHostStatus("Oferta criada. Enviando oferta via NFC...");
          // Envia a oferta via NFC (isso solicitará a permissão para NFC, se necessário)
          await writeNFC(JSON.stringify(offer));
          setHostStatus("Oferta enviada. Aguardando resposta via NFC...");
          // Após enviar a oferta, o host passa a ler a resposta
          listenForNFCAnswer();
        }
      };

      // Cria a oferta do WebRTC
      try {
        let offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
      } catch (e) {
        setHostStatus("Erro ao criar a oferta: " + e);
      }
    }

    // Função para enviar arquivo do Host
    function sendFile() {
      const fileInput = document.getElementById("fileInput");
      if (fileInput.files.length === 0) {
        alert("Selecione um arquivo primeiro.");
        return;
      }
      const file = fileInput.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        // Aqui o arquivo é lido como texto para simplificar o exemplo.
        // Para arquivos binários, use ArrayBuffer e implemente fragmentação/reconstrução.
        dataChannel.send(reader.result);
        setHostStatus("Arquivo enviado: " + file.name);
      };
      reader.readAsText(file);
    }

    function setHostStatus(msg) {
      document.getElementById("hostStatus").innerText = msg;
    }

    // -------------------------
    // Fluxo para o HOSPEDEIRO
    async function startGuest() {
      setGuestStatus("Aguardando leitura da oferta via NFC...");
      // Utiliza o Web NFC para ler a oferta do host
      if ("NDEFReader" in window) {
        try {
          const ndef = new NDEFReader();
          await ndef.scan();
          ndef.onreading = async (event) => {
            // Processa todos os registros da mensagem NFC
            for (const record of event.message.records) {
              if (record.recordType === "text") {
                let offerText = new TextDecoder(record.encoding).decode(record.data);
                setGuestStatus("Oferta recebida via NFC. Conectando...");
                // Cria a conexão como hospedeiro
                await connectAsGuest(JSON.parse(offerText));
              }
            }
          };
        } catch (e) {
          setGuestStatus("Erro ao ler NFC: " + e);
        }
      } else {
        setGuestStatus("Web NFC não suportado neste dispositivo.");
      }
    }

    async function connectAsGuest(offer) {
      peerConnection = new RTCPeerConnection(configuration);
      // Quando o hospedeiro receber a DataChannel do host
      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        dataChannel.onmessage = (e) => {
          document.getElementById("guestTransfer").classList.remove("hidden");
          document.getElementById("receivedFile").innerText = "Arquivo recebido: " + e.data;
        };
        dataChannel.onopen = () => {
          setGuestStatus("Conexão estabelecida!");
        };
      };

      try {
        // Configura a oferta recebida
        await peerConnection.setRemoteDescription(offer);
        // Cria uma resposta
        let answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        setGuestStatus("Criando resposta. Enviando resposta via NFC...");
        // Envia a resposta via NFC para o host ler
        await writeNFC(JSON.stringify(answer));
        setGuestStatus("Resposta enviada. Conexão sendo estabelecida...");
      } catch (e) {
        setGuestStatus("Erro durante a conexão: " + e);
      }
    }

    function setGuestStatus(msg) {
      document.getElementById("guestStatus").innerText = msg;
    }

    // -------------------------
    // Funções para escrita e leitura NFC
    async function writeNFC(message) {
      if ("NDEFReader" in window) {
        try {
          const ndef = new NDEFReader();
          await ndef.write(message);
          console.log("Mensagem NFC escrita:", message);
        } catch (e) {
          console.error("Erro ao escrever NFC:", e);
          throw e;
        }
      } else {
        throw new Error("Web NFC não suportado.");
      }
    }

    // No host, após enviar a oferta, escuta a resposta via NFC
    async function listenForNFCAnswer() {
      if ("NDEFReader" in window) {
        try {
          const ndef = new NDEFReader();
          await ndef.scan();
          ndef.onreading = async (event) => {
            for (const record of event.message.records) {
              if (record.recordType === "text") {
                let answerText = new TextDecoder(record.encoding).decode(record.data);
                setHostStatus("Resposta NFC recebida. Finalizando conexão...");
                await peerConnection.setRemoteDescription(JSON.parse(answerText));
              }
            }
          };
        } catch (e) {
          setHostStatus("Erro ao ler resposta NFC: " + e);
        }
      }
    }
  </script>
</body>
</html>
